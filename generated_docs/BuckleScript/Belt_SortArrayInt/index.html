<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Belt_SortArrayInt (BuckleScript.Belt_SortArrayInt)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="..">Up</a> â€“ <a href="../">BuckleScript</a> &#x00BB; Belt_SortArrayInt</nav><h1>Module <code>Belt_SortArrayInt</code></h1><p>This is a specialized module for <code>Belt_SortArray</code>, the docs in that module also applies here, except the comparator is fixed and inlined</p></header><dl><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">type </span>element</code><code><span class="keyword"> = </span>int</code><span class="keyword">;</span></dt></dl><dl><dt class="spec value" id="val-strictlySortedLength"><a href="#val-strictlySortedLength" class="anchor"></a><code><span class="keyword">let </span>strictlySortedLength: array(<a href="#type-element">element</a>) <span>=&gt;</span> int<span class="keyword">;</span></code></dt><dd><p>The same as <span class="xref-unresolved" title="unresolved reference to &quot;Belt_SortArray.strictlySortedLength&quot;"><code>Belt_SortArray</code>.strictlySortedLength</span> except the comparator is fixed</p><dl><dt>returns</dt><dd><p><code>+n</code> means increasing order <code>-n</code> means negative order</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-isSorted"><a href="#val-isSorted" class="anchor"></a><code><span class="keyword">let </span>isSorted: array(<a href="#type-element">element</a>) <span>=&gt;</span> bool<span class="keyword">;</span></code></dt><dd><p><code>sorted xs</code> return true if <code>xs</code> is in non strict increasing order</p></dd></dl><dl><dt class="spec value" id="val-stableSortInPlace"><a href="#val-stableSortInPlace" class="anchor"></a><code><span class="keyword">let </span>stableSortInPlace: array(<a href="#type-element">element</a>) <span>=&gt;</span> unit<span class="keyword">;</span></code></dt><dd><p>The same as <span class="xref-unresolved" title="unresolved reference to &quot;Belt_SortArray.stableSortInPlaceBy&quot;"><code>Belt_SortArray</code>.stableSortInPlaceBy</span> except the comparator is fixed</p></dd></dl><dl><dt class="spec value" id="val-stableSort"><a href="#val-stableSort" class="anchor"></a><code><span class="keyword">let </span>stableSort: array(<a href="#type-element">element</a>) <span>=&gt;</span> array(<a href="#type-element">element</a>)<span class="keyword">;</span></code></dt><dd><p>The same as <span class="xref-unresolved" title="unresolved reference to &quot;Belt_SortArray.stableSortBy&quot;"><code>Belt_SortArray</code>.stableSortBy</span> except the comparator is fixed</p></dd></dl><dl><dt class="spec value" id="val-binarySearch"><a href="#val-binarySearch" class="anchor"></a><code><span class="keyword">let </span>binarySearch: array(<a href="#type-element">element</a>) <span>=&gt;</span> <a href="#type-element">element</a> <span>=&gt;</span> int<span class="keyword">;</span></code></dt><dd><p>If value is not found and value is less than one or more elements in array, the negative number returned is the bitwise complement of the index of the first element that is larger than value.</p><p>If value is not found and value is greater than all elements in array, the negative number returned is the bitwise complement of (the index of the last element plus 1)</p><p>for example, if <code>key</code> is smaller than all elements return <code>-1</code> since <code>lnot (-1) = 0</code> if <code>key</code> is larger than all elements return <code>- (len + 1)</code> since <code>lnot (-(len+1)) = len</code></p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">let </span>union: array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int <span>=&gt;</span> array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int <span>=&gt;</span> array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int<span class="keyword">;</span></code></dt><dd><p>/*</p><p><code>union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp</code> assume <code>src</code> and <code>src2</code> is strictly sorted. for equivalent elements, it is picked from <code>src</code> also assume that <code>dst</code> is large enough to store all elements</p></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">let </span>intersect: array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int <span>=&gt;</span> array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int <span>=&gt;</span> array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int<span class="keyword">;</span></code></dt><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">let </span>diff: array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int <span>=&gt;</span> array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int <span>=&gt;</span> array(<a href="#type-element">element</a>) <span>=&gt;</span> int <span>=&gt;</span> int<span class="keyword">;</span></code></dt><dd><p>/*</p></dd></dl></div></body></html>